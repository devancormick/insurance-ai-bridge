# PostgreSQL Cluster Configuration
# High-availability PostgreSQL cluster with Patroni and PgBouncer

apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-cluster-config
  namespace: insurance-ai-bridge
data:
  patroni.yml: |
    scope: insurance-ai-bridge
    namespace: /insurance-ai-bridge/
    name: postgres-primary
    
    restapi:
      listen: 0.0.0.0:8008
      connect_address: ${PATRONI_RESTAPI_CONNECT_ADDRESS}
      authentication:
        username: patroni
        password: ${PATRONI_RESTAPI_PASSWORD}
    
    bootstrap:
      dcs:
        ttl: 30
        loop_wait: 10
        retry_timeout: 30
        maximum_lag_on_failover: 1048576
        postgresql:
          use_pg_rewind: true
          use_slots: true
          parameters:
            wal_level: logical
            hot_standby: "on"
            wal_keep_segments: 64
            max_connections: 200
            max_worker_processes: 8
            max_wal_senders: 10
            wal_log_hints: "on"
            max_replication_slots: 10
            track_commit_timestamp: "on"
            synchronous_commit: "remote_write"
            synchronous_standby_names: "ANY 2 (postgres-replica-1,postgres-replica-2)"
      initdb:
      - encoding: UTF8
      - locale: en_US.UTF-8
      - data-checksums
      pg_hba:
      - host replication replicator 0.0.0.0/0 md5
      - host all all 0.0.0.0/0 md5
    
    postgresql:
      listen: 0.0.0.0:5432
      connect_address: ${PATRONI_POSTGRESQL_CONNECT_ADDRESS}
      data_dir: /var/lib/postgresql/data
      pgpass: /tmp/pgpass
      authentication:
        replication:
          username: replicator
          password: ${POSTGRES_REPLICATION_PASSWORD}
        superuser:
          username: postgres
          password: ${POSTGRES_SUPERUSER_PASSWORD}
      parameters:
        unix_socket_directories: '/var/run/postgresql'
        shared_buffers: 4GB
        effective_cache_size: 12GB
        maintenance_work_mem: 1GB
        checkpoint_completion_target: 0.9
        wal_buffers: 16MB
        default_statistics_target: 100
        random_page_cost: 1.1
        effective_io_concurrency: 200
        work_mem: 32MB
        min_wal_size: 1GB
        max_wal_size: 4GB
        max_connections: 200
        max_worker_processes: 8
        max_parallel_workers_per_gather: 4
        max_parallel_workers: 8
        max_parallel_maintenance_workers: 4
    
    watchdog:
      mode: required
      device: /dev/watchdog
      safety_margin: 5
    
    tags:
      nofailover: false
      noloadbalance: false
      clonefrom: false
      nosync: false

---
# PgBouncer Connection Pooler Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: pgbouncer-config
  namespace: insurance-ai-bridge
data:
  pgbouncer.ini: |
    [databases]
    insurance_ai_bridge = host=postgres-primary.insurance-ai-bridge.svc.cluster.local port=5432 dbname=insurance_ai_bridge
    
    [pgbouncer]
    listen_addr = 0.0.0.0
    listen_port = 6432
    auth_type = md5
    auth_file = /etc/pgbouncer/userlist.txt
    pool_mode = transaction
    max_client_conn = 10000
    default_pool_size = 100
    min_pool_size = 20
    reserve_pool_size = 10
    reserve_pool_timeout = 3
    max_db_connections = 1000
    max_user_connections = 1000
    server_round_robin = 1
    log_connections = 1
    log_disconnections = 1
    log_pooler_errors = 1
    application_name_add_host = 1
    stats_period = 60
    verbose = 0
    admin_users = postgres
    ignore_startup_parameters = extra_float_digits

